<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Base32编码]]></title>
    <url>%2F2018%2F03%2F08%2FBase32%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[这是一个基于32个编码表示的数字系统参考维基百科/wiki/Base32]]></content>
      <categories>
        <category>计算机基础科学</category>
      </categories>
      <tags>
        <tag>Base32</tag>
        <tag>加密</tag>
        <tag>解密</tag>
        <tag>计算机基础科学</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base64编码]]></title>
    <url>%2F2018%2F03%2F08%2FBase64%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Base64这是一个基于64位字符表示的数字系统，只用64个字符可转换来代表二进制数值或其他进制字符。在计算机科学中这64个字符，一般选取ASCII码其中64个字符来表示数码。Base64有不同的设计版本，对应不同字符表(编码表)，其中前62个字符对应的是：26个字母大小写，10个数字。第63和64位，这最后2个字符因不同的操作系统设计标准，历史不同版本设计协议，和电子通信环境需求，选用了不同符号表示。详细请参考维基百科/wiki/Base64，以下是标准Base64编码表。 Value Char Value Char Value Char Value Char 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 W 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / Base64加密解密算法原理明文字符串,举个栗子abcd,里每个单字符对应ASCII编码表都有二进制的的8位字节表示，如： 原文字符串 ASCII字符码 a b c d ASCII二进制码 01100001 01100010 01100011 01100100 手算数学步骤： 步骤1==&gt; 分段处理字符串，每段读取3个字节 [ 01100001 01100010 01100011] [01100100] 步骤2==&gt; 将每段每个原来的8位3个字节，分成6位4个字节 [ 011000 010110 001001 100011] [011001 00] 步骤3==&gt; 给不足6位4个字节的数据段填充0，输出字符使用 ‘=’ [011000 010110 001001 100011] [011001 000000 000000 000000 ] (可选)步骤4==&gt; 转换成十进制 [ 24 22 9 35 ][ 25 0 = = ] 步骤5==&gt; 查Base64编码表 [ Y W J j ][ Z A = = ] 计算机数学计算步骤： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172输入：abcd处理：Base64编码 encode加密输出：YWJjZA==[a b c] [d][01100001 01100010 01100011] [01100100][011000 01 0110 0010 01 100011] [011001 00]/*---------数据第一分段处理------------*/[01100001 01100010 01100011]// ### 处理第1字节a01100001011000-- &gt;&gt;2 // 01100001向右移2位 01100001=&gt;xx011000011000 24Y //输出结果 Y , 在Base64编码表十进制值为24// ### 处理第2字节a b01100001 01100010------01 &lt;&lt;6 // 高位01100001向左移6位 01100001=&gt;01xxxxxx----0001 &gt;&gt;2 // 01xxxxxx向右移2位 01xxxxxx=&gt;xx01xxxx0110---- &gt;&gt;4 // 低位01100010向右移4位 01100010=&gt;xxxx011001011000010110 //高位 0001xxxx 添加 低位 xxxx0110, 0001xxxx | xxxx0110=0001011022G //输出结果 G , 在Base64编码表十进制值为22// ### 处理第3字节b c01100010 01100011----0010 &lt;&lt;4 // 高位01100010向左移4位 01100010=&gt;0010xxxx--000010 &gt;&gt;2 // 0010xxxx向右移2位 0010xxxx=&gt;xx0010xx01------ &gt;&gt;6 // 低位01100011向右移6位 01100011=&gt;xxxxxx01001001 // 高位 xx0010xx 添加 低位 xxxxxx01, xx0010xx|xxxxxx01=000010019J //输出结果 J , 在Base64编码表十进制值为9// ### 处理第4字节c01100011--100011 // 01100011取最后6位， 即对 00111111 &amp; 01100011 = 0010001135j //输出结果 j , 在Base64编码表十进制值为35/*---------数据第二分段处理------------*/[01100100 00000000 00000000]// ### 处理第1字节d01100100011001-- &gt;&gt;2 // 01100100向右移2位 01100100=&gt;xx0110010110010001100125Z //输出结果 Z , 在Base64编码表十进制值为25// ### 处理第2字节d null01100100 00000000------00 &lt;&lt;6 // 高位01100100向左移6位 01100100=&gt;00xxxxxx----0000 &gt;&gt;2 // 01100100向右移2位 00xxxxxx=&gt;xx00xxxx0000---- &gt;&gt;4 // 低位00000000向右移4位 00000000=&gt;xxxx0000000000 // 高位 xx00xxxx 添加 低位 xxxx0000, xx00xxxx|xxxx0000=00000000000000000A //输出结果 A , 在Base64编码表十进制值为0// ### 处理填充字节null null00000000 00000000= // 输出结果 = , 填充码= // 输出结果 = , 填充码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293输入：YWJjZA==处理：Base64编码 decode解密输出：abcd---------------------------------------Y W J j Z A = =(ascii) --&gt; (base64)[01011001 01010111 01001010][01101010 01011010 00111101 00111101](ascii) Y 01011001 89 - (ascii) A 01000001 65 = (base64) 24 00011000 Y(ascii) W 01010111 87 - (ascii) A 01000001 65 = (base64) 22 00010110 W(ascii) J 01001010 74 - (ascii) A 01000001 65 = (base64) 9 00001001 J(ascii) j 01101010 106 - (ascii) A 01100001 65 - 6 = (base64) 35 00100011 j(ascii) Z 01011010 90 - (ascii) A 01000001 65 = (base64) 25 00011001‬ Z(ascii) = 00111101 61 - (ascii) A 01000001 65 = -4 00000000(ascii) = 00111101 61 - (ascii) A 01000001 65 = -4 00000000[0-9](ascii) 0 00110000 48 - (ascii) A 01000001 65 + 69 = (base64) 52 000011001‬ 0(ascii) 0 00110000 48 - (-4) = (base64) 52 000011001‬ 0(ascii) 9 00110000 57 - (-4) = (base64) 61 000011001‬ 9[a-z](ascii) j 01101010 106 - (ascii) A 01100001 65 - 6 = (base64) 35 00100011 j(ascii) j 01101010 106 - 71 = (base64) 35 00100011 j[+/](ascii) + 00101011 43 - (-19) = (base64) 62 00111110 +(ascii) / 00101111 47 - (-16) = (base64) 63 00111111 /(base64)[00011000 00010110 00001001 00100011] [00011001‬ 00000000 00111101 00111101]00011000 --01 0110 --0010 01 --100011/*---------数据第一分段处理------------*/[00011000 00010110 00001001 00100011] Y W J jY W00011000 0001011000011000 --011000 &lt;&lt;2 //高位00011000 向左移2位 00011000=&gt;011000xx00010110 01---- &gt;&gt;4 //低位00010110 向右移4位 00010110=&gt;xxxx000101100001 //高位011000xx 添加 低位 xxxxxx01, 01100000 | 00000001 = 0110000197a //输出结果 a , 在ASCII编码表十进制值为97W J00010110 0000100100010110----0110 &lt;&lt;4 //高位00010110 向左移4位 00010110=&gt;0110xxxx00001001000010-- &gt;&gt;2 //低位00001001向右移2位 00001001=&gt;xx00001001100010 //高位0110xxxx 添加 低位 xx000010, 0110xxxx | xx000010 = 0110001098b //输出结果 b , 在ASCII编码表十进制值为98J j00001001 0010001100001001------01 &lt;&lt;6 // 高位 00001001向左移6位 00001001=&gt;01xxxxxx00100011 // 保留低位 0010001101100011 // 高位 01xxxxxx 添加 00100011, 01xxxxxx | 00100011 = 0110001199c //输出结果 c , 在ASCII编码表十进制值为99/*---------数据第二分段处理------------*/[00011001‬ 00000000 00111101 00111101] Z A = =Z A00011001‬ 0000000000011001‬ --011001 &lt;&lt;2 // 高位 00011001‬ 向左移2位 00011001‬=&gt;011001‬xx00000000 00---- &gt;&gt;4 // 低位 00000000 向右移4位 00000000=&gt;xxxx000001100100 // 高位 011001‬xx 添加 低位 xxxx0000, 011001‬xx | xxxx0000 = 01100100100d //输出结果 d , 在ASCII编码表十进制值为100A =00000000 0011110100000000----0000 &lt;&lt;4 // 高位 00000000 向左移4位 00000000=&gt;0000xxxx00111101001111-- &gt;&gt;2 // 低位 00111101 向右移2位 00111101=&gt;xx00111100001111 // 高位 0000xxxx 添加 低位 xx001111, 0000xxxx | xx001111 = 000011110x0F15SI (shift in) 启用切换 //输出结果 SI , 在ASCII编码表十进制值为15= =00111101 0011110100111101------01 &lt;&lt;6 // 高位 00001001向左移6位 00111101=&gt;01xxxxxx00111101 // 保留低位 0011110101111101 // 高位 01xxxxxx 添加 00100011, 01xxxxxx | 00111101 = 01111101125&#123; //输出结果 &#123; , 在ASCII编码表十进制值为125 计算机编程语言 JavaScript 代码实现 [源代码下载]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227/*** 作者：Weijun Lai** 时间：2018年3月9日** 版本：1.0** 说明：实现Base64编码的加密和解密功能。** 并未对执行效率，最大处理能力和** 书写简洁做优化，仅对算法细分解析。** 为了便于阅读，已将原来一行复合运算代码分解成多行，因此占用了更多变量** 本代码用for循环处理将会有处理字符串长度最大为integer数据类型大小的限制***/// base64编码表var base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";// base64编码表最后两位var char62 = '+';var char63 = '/';base64Table += char62+char63;/*** base64 加密** @param &#123;code&#125; String 输入字符串明文** @return &#123;encode&#125; String 输出字符串密文*/function base64_encode(code) &#123;/* 加密算法流程 1.分段处理，每段处理三字节 以下将每段(8位三字节)转为每段(6位四字节) 2.处理第1字节 2.1高位向右移2位 3.处理第2字节 3.1高位向左移6位 3.2高位向右移2位 3.3高位取最后6位，即 与运算 00111111 (0x3F) 3.4低位向右移4位 3.5高低位或运算 4.处理第3字节 4.1高位向左移4位 4.2高位向右移2位 4.3高位取最后6位，即 与运算 00111111 (0x3F) 4.4低位向右移6位 4.5高低位或运算 5.处理第4字节 5.5取最后6位，即 与运算 00111111 (0x3F) 6.处理分段不足三字节长度的填充 6.1分段内字节数量长度缺2个满足三字节的补2个等号'=' 6.2分段内字节数量长度缺1个满足三字节的补1个等号'='*/ var byte1 = 0; // 寄存处理第1字节的变量 var byte2 = 0; // 寄存处理第2字节的变量 var byte3 = 0; // 寄存处理第3字节的变量 var byte4 = 0; // 寄存处理第4字节的变量 var encode = ""; // 寄存Base64加密后输出结果的变量 // 1.分段处理，每段处理三字节 for (var i=0;i&lt;code.length;i=i+3) &#123; // 2.处理第1字节 byte1 = code[i].charCodeAt(); //获取ascii编码表对应的值 byte1 = byte1&gt;&gt;2; //2.1高位向右移2位 byte1 = byte1&amp;0x3F;//2.3高位取最后6位，即 与运算 00111111 (0x3F) encode += base64Table[byte1]; //查Base64编码表对应的值 // 6.处理分段不足三字节长度的填充 if (i+2-code.length==1) &#123; //6.1分段内字节数量长度缺2个字节满足三字节的补2个等号'=' byte1 = code[i].charCodeAt(); //获取ascii编码表对应的值,记为高位 byte2 = 0; //填充零，记为低位 byte1 = byte1&lt;&lt;6;//3.1高位向左移6位 byte1 = byte1&gt;&gt;2;//3.2高位向右移2位 byte1 = byte1&amp;0x3F;//3.3高位取最后6位，即 与运算 00111111 (0x3F) byte2 = byte2&gt;&gt;4;//3.4低位向右移4位 byte2 = byte1|byte2;//3.5高低位或运算 encode += base64Table[byte2]; //查Base64编码表对应的值 encode += "=="; break; &#125; // 处理第2字节 byte1 = code[i].charCodeAt(); //获取ascii编码表对应的值,记为高位 byte2 = code[i+1].charCodeAt(); //获取ascii编码表对应的值,记为低位 byte1 = byte1&lt;&lt;6;//3.1高位向左移6位 byte1 = byte1&gt;&gt;2;//3.2高位向右移2位 byte1 = byte1&amp;0x3F;//3.3高位取最后6位，即 与运算 00111111 (0x3F) byte2 = byte2&gt;&gt;4;//3.4低位向右移4位 byte2 = byte1|byte2;//3.5高低位或运算 encode += base64Table[byte2]; //查Base64编码表对应的值 // 6.处理分段不足三字节长度的填充 if (i+2-code.length==0) &#123; //6.2分段内字节数量长度缺1个字节满足三字节的补1个等号'=' byte2 = code[i+1].charCodeAt(); //获取ascii编码表对应的值,记为高位 byte3 = 0; //填充零，记为低位 byte2 = byte2&lt;&lt;4;//4.1高位向左移4位 byte2 = byte2&gt;&gt;2;//4.2高位向右移2位 byte2 = byte2&amp;0x3F;//4.3高位取最后6位，即 与运算 00111111 (0x3F) byte3 = byte3&gt;&gt;6;//4.4低位向右移6位 byte3 = byte2|byte3;//4.5高低位或运算 encode += base64Table[byte3]; //查Base64编码表对应的值 encode += "="; break; &#125; // 处理第3字节 byte2 = code[i+1].charCodeAt(); //获取ascii编码表对应的值,记为高位 byte3 = code[i+2].charCodeAt(); //获取ascii编码表对应的值,记为低位 byte2 = byte2&lt;&lt;4;//4.1高位向左移4位 byte2 = byte2&gt;&gt;2;//4.2高位向右移2位 byte2 = byte2&amp;0x3F;//4.3高位取最后6位，即 与运算 00111111 (0x3F) byte3 = byte3&gt;&gt;6;//4.4低位向右移6位 byte3 = byte2|byte3;//4.5高低位或运算 encode += base64Table[byte3]; //查Base64编码表对应的值 // 处理第4字节 byte4 = code[i+2].charCodeAt(); //获取ascii编码表对应的值 byte4 = byte4&amp;0x3F;//5.5取最后6位，即 与运算 00111111 (0x3F) encode += base64Table[byte4]; //查Base64编码表对应的值 &#125; return encode;&#125;/* ascii编码表 映射ascii编码 到 base64编码表** @param &#123;char&#125; 输入单字符** @return &#123;integer&#125; 输出整数*/function asciiToBase64(code) &#123; var char = ""; try&#123; char = code.charCodeAt(); &#125;catch (e)&#123; return -1; &#125; if (char == char62.charCodeAt()) &#123; // '+' 的ascii编码映射base64编码 return 62; &#125; else if (char == char63.charCodeAt()) &#123; // '-' 的ascii编码映射base64编码 return 63; &#125; else if (char &gt;= '0'.charCodeAt() &amp;&amp; char &lt;= '9'.charCodeAt()) &#123; // [0-9]范围的ascii编码映射到[0-9]范围的base64编码 return char+4; &#125; else if (char &gt;= 'A'.charCodeAt() &amp;&amp; char &lt;= 'Z'.charCodeAt()) &#123; // [A-Z]范围的ascii编码映射到[A-Z]范围的base64编码 return char-65; &#125; else if (char &gt;= 'a'.charCodeAt() &amp;&amp; char &lt;= 'z'.charCodeAt()) &#123; // [a-z]范围的ascii编码映射到[a-z]范围的base64编码 return char-71; &#125; return -1;&#125;/*** base64 解密** @param &#123;code&#125; String 输入字符串密文** @return &#123;encode&#125; String 输出字符串明文*/function base64_decode(code) &#123; /* 解密算法流程 1.分段处理，每段四字节，将每个加密字节从ascii编码表映射到Base64编码表 以下将每段(8位四字节)转为每段(8位三字节) 2.处理第1字节 2.1高位向左移2位 2.2高位取最后8位，即 与运算 11111111 (0xFF) 2.3低位向右移4位 2.4高低位或运算 3.处理第2字节 3.1高位向左移4位 3.2高位取最后8位，即 与运算 11111111 (0xFF) 3.3低位向右移2位 3.4高低位或运算 4.处理第3字节 4.1高位向左移6位 4.2高位取最后8位，即 与运算 11111111 (0xFF) 4.3低位保留 4.4高低位或运算 5.处理填充代表等号字符= 5.1结束处理 */ var byte1 = 0; // 寄存处理第1字节的变量 var byte2 = 0; // 寄存处理第2字节的变量 var byte3 = 0; // 寄存处理第3字节的变量 var byte4 = 0; // 寄存处理第4字节的变量 var decode = ""; // 寄存Base64解密后输出结果的变量 //1.分段处理，每段四字节，将每个加密字节从ascii编码表映射到Base64编码表 for (var i=0;i&lt;code.length;i=i+4) &#123; //5.处理填充代表等号字符= if (asciiToBase64(code[i])==-1 || asciiToBase64(code[i+1])==-1) &#123; break; &#125; //2.处理第1字节 byte1 = asciiToBase64(code[i]);//获取ascii编码表映射到Base64编码表对应的值,记为高位 byte2 = asciiToBase64(code[i+1]);//获取ascii编码表映射到Base64编码表对应的值,记为低位 byte1 = byte1&lt;&lt;2;//2.1高位向左移2位 byte1 = byte1&amp;0xFF;//2.2高位取最后8位，即 与运算 11111111 (0xFF) byte2 = byte2&gt;&gt;4;//2.3低位向右移4位 byte1 = byte1|byte2;//2.4高低位或运算 decode += String.fromCharCode(byte1);//查ascii编码表对应的值 //5.处理填充代表等号字符= if (asciiToBase64(code[i+1])==-1 || asciiToBase64(code[i+2])==-1) &#123; break; &#125; //3.处理第2字节 byte2 = asciiToBase64(code[i+1]);//获取ascii编码表映射到Base64编码表对应的值,记为高位 byte3 = asciiToBase64(code[i+2]);//获取ascii编码表映射到Base64编码表对应的值,记为低位 byte2 = byte2&lt;&lt;4;//3.1高位向左移4位 byte2 = byte2&amp;0xFF;//2.3高位取最后8位，即 与运算 11111111 (0xFF) byte3 = byte3&gt;&gt;2;//2.3低位向右移2位 byte2 = byte2|byte3;//2.4高低位或运算 decode += String.fromCharCode(byte2);//查ascii编码表对应的值 //5.处理填充代表等号字符= if (asciiToBase64(code[i+2])==-1 || asciiToBase64(code[i+3])==-1) &#123; break; &#125; //4.处理第3字节 byte3 = asciiToBase64(code[i+2]);//获取ascii编码表映射到Base64编码表对应的值,记为高位 byte4 = asciiToBase64(code[i+3]);//获取ascii编码表映射到Base64编码表对应的值,记为低位 byte3 = byte3&lt;&lt;6;//3.1高位向左移6位 byte3 = byte3&amp;0xFF;//2.3高位取最后8位，即 与运算 11111111 (0xFF) byte4 = byte4;//2.3低位保留 byte3 = byte3|byte4;//2.4高低位或运算 decode += String.fromCharCode(byte3);//查ascii编码表对应的值 &#125; return decode;&#125; 来自 crypto-js.js Base64部分源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104(function () &#123; // Shortcuts var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var C_enc = C.enc; /** * Base64 encoding strategy. */ var Base64 = C_enc.Base64 = &#123; /** * Converts a word array to a Base64 string. * * @param &#123;WordArray&#125; wordArray The word array. * * @return &#123;string&#125; The Base64 string. * * @static * * @example * * var base64String = CryptoJS.enc.Base64.stringify(wordArray); */ stringify: function (wordArray) &#123; // Shortcuts var words = wordArray.words; var sigBytes = wordArray.sigBytes; var map = this._map; // Clamp excess bits wordArray.clamp(); // Convert var base64Chars = []; for (var i = 0; i &lt; sigBytes; i += 3) &#123; var byte1 = (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff; var byte2 = (words[(i + 1) &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - ((i + 1) % 4) * 8)) &amp; 0xff; var byte3 = (words[(i + 2) &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - ((i + 2) % 4) * 8)) &amp; 0xff; var triplet = (byte1 &lt;&lt; 16) | (byte2 &lt;&lt; 8) | byte3; for (var j = 0; (j &lt; 4) &amp;&amp; (i + j * 0.75 &lt; sigBytes); j++) &#123; base64Chars.push(map.charAt((triplet &gt;&gt;&gt; (6 * (3 - j))) &amp; 0x3f)); &#125; &#125; // Add padding var paddingChar = map.charAt(64); if (paddingChar) &#123; while (base64Chars.length % 4) &#123; base64Chars.push(paddingChar); &#125; &#125; return base64Chars.join(''); &#125;, /** * Converts a Base64 string to a word array. * * @param &#123;string&#125; base64Str The Base64 string. * * @return &#123;WordArray&#125; The word array. * * @static * * @example * * var wordArray = CryptoJS.enc.Base64.parse(base64String); */ parse: function (base64Str) &#123; // Shortcuts var base64StrLength = base64Str.length; var map = this._map; // Ignore padding var paddingChar = map.charAt(64); if (paddingChar) &#123; var paddingIndex = base64Str.indexOf(paddingChar); if (paddingIndex != -1) &#123; base64StrLength = paddingIndex; &#125; &#125; // Convert var words = []; var nBytes = 0; for (var i = 0; i &lt; base64StrLength; i++) &#123; if (i % 4) &#123; var bits1 = map.indexOf(base64Str.charAt(i - 1)) &lt;&lt; ((i % 4) * 2); var bits2 = map.indexOf(base64Str.charAt(i)) &gt;&gt;&gt; (6 - (i % 4) * 2); var bitsCombined = bits1 | bits2; words[nBytes &gt;&gt;&gt; 2] |= (bitsCombined) &lt;&lt; (24 - (nBytes % 4) * 8); nBytes++; &#125; &#125; return WordArray.create(words, nBytes); &#125;, _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' &#125;;&#125;());]]></content>
      <categories>
        <category>计算机基础科学</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>解密</tag>
        <tag>计算机基础科学</tag>
        <tag>原理</tag>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载地址解析]]></title>
    <url>%2F2018%2F03%2F07%2F%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 应用程序 By Weijun Lai, Version: 1.0 请输入下载链接地址：迅雷 快车 旋风 磁力 解析转换 0x02 技术解析： 各类下载链接地址都有固定的编码格式，便于网络通信程序识别和处理。以下收集了些各类常见链接协议的固定格式。 0x021 固定格式 &#124; HTTP链接地址 http:// 12&lt;明文URL&gt;http://laiweijun.com/file.txt 迅雷链接地址 thunder:// 123456thunder://AA&lt;明文URL&gt;ZZ[处理]AA&lt;明文URL&gt;ZZ ==&gt; AAhttp://laiweijun.com/file.txtZZ==&gt; Base64编码 ==&gt; QUFodHRwJTNBLy9sYWl3ZWlqdW4uY29tL2ZpbGUudHh0Wlo=[输出]thunder://QUFodHRwJTNBLy9sYWl3ZWlqdW4uY29tL2ZpbGUudHh0Wlo= 磁力链接格式 magnet:? 1234magnet:?xl=&lt;字节大小&gt; &amp; dn=&lt;文件名(已编码URL)&gt; &amp; xt=urn:tree:tiger:&lt;TTH hash(Base32)&gt;magnet:?xt=urn:btih:D84ABC1F6605F03BC363E758805EC1A1550DA751v1: magnet:?xt=urn:btih:&lt;info-hash&gt;&amp;dn=&lt;name&gt;&amp;tr=&lt;tracker-url&gt;&amp;x.pe=&lt;peer-address&gt;v2: magnet:?xt=urn:btmh:&lt;tagged-info-hash&gt;&amp;dn=&lt;name&gt;&amp;tr=&lt;tracker-url&gt;&amp;x.pe=&lt;peer-address&gt; 参数 dn（显示名称）- display name的缩写，表示向用户显示的文件名。这是可选项。 xl（绝对长度）- 文件字节数 xt（eXact Topic）- exact topic的缩写，包含文件散列函数值的 URN, 表示资源定位点 BTIH（BitTorrent Info Hash）表示哈希方法名，这里还可以使用SHA1和MD5 as（可接受来源） - 在线文件的网络链接 xs（绝对资源）- P2P链接 kt（关键字）- 用于搜索的关键字 mt（文件列表）- 链接到一个包含磁力连结的元文件 (MAGMA - MAGnet MAnifest) tr（Tracker 地址）- BT下载的Tracker URL 快车链接地址 flashget:// 1234flashget://[FLASHGET]&lt;明文URL&gt;[FLASHGET]==&gt; [FLASHGET]http://laiweijun.com/file.txt[FLASHGET]==&gt; Base64编码 ==&gt; JTVCRkxBU0hHRVQlNURodHRwJTNBLy9sYWl3ZWlqdW4uY29tL2ZpbGUudHh0JTVCRkxBU0hHRVQlNUQ=&amp;anycodeflashget://JTVCRkxBU0hHRVQlNURodHRwJTNBLy9sYWl3ZWlqdW4uY29tL2ZpbGUudHh0JTVCRkxBU0hHRVQlNUQ=&amp;anycode 旋风链接地址 qqdl:// 12qqdl://&lt;已编码URL&gt;qqdl://aHR0cCUzQS8vbGFpd2VpanVuLmNvbS9maWxlLnR4dA== 电驴链接地址 ed2k:// 12ed2k://|file|&lt;文件名称&gt;|&lt;文件大小&gt;|&lt;文件哈希值&gt;|/ed2k://|file|cn_windows_10_multi-edition_vl_version_1709_updated_dec_2017_x64_dvd_100406208.iso|5007116288|317BDC520FA2DD6005CBA8293EA06DF6|/ 0x022 编码Base64 Base32 Base16 Base85 Base16 Base64详细可查看Base64编码这篇文章 Base32详细可查看Base32编码这篇文章]]></content>
      <categories>
        <category>WebApp</category>
      </categories>
      <tags>
        <tag>下载</tag>
        <tag>解析</tag>
        <tag>应用</tag>
        <tag>迅雷</tag>
        <tag>磁力</tag>
        <tag>快车</tag>
        <tag>旋风</tag>
        <tag>电驴</tag>
        <tag>BT种子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018两会学习]]></title>
    <url>%2F2018%2F03%2F07%2F2018%E4%B8%A4%E4%BC%9A%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[今年两会发了很多个大红包，减轻了各种人群生产活动的负担，鼓励更多人参与劳动致富走向更好生活质量的中国梦。 简要 ~~ √ 取消漫游流量 城乡网络全覆盖 ~~ √ 提高个人所得税起征点 ~~ √ 鼓励创业 发展智能产业 ~~ √ 数字中国….]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>两会</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒空间布局]]></title>
    <url>%2F2018%2F03%2F06%2F%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[请输入密码 U2FsdGVkX19uaOz9aRWRGouMbgrhvPUR0a93AO9w3xLtmYBaSSM80f70jewl7W+bx3j3qMzLWAY7gSE1CL1OF4mIZmwrRxLn6rh/GAZpKKw5bKVhEb7GUpN9MG1zu+lBp5lCdnmGY3saQtil0pUjuf+fKufUsWqN6PlgOvIn/0FzJsEkKi4hQ3JoAPOagG5cwymiCGY85C7PqT9wprDhPdmpxtVHfsk3MRgxYRovt5Hq6xtQly5mBd3VNuevn3UUPkQGNdTAf9ZcZOf9yViBW8UzHG5Fgj6YIpgzyIfx/vBVjpM2iexfaeg3jMvQMJ1TA3np5GhRCpy7SLxww0z8rWMsf3zsTG1pEMlkvBikac/XBohkXGUBswfoEfAR26hdVkQUdXp/OvK1XyLvrrgDJgesBHg7dqro/uBxy5LiCCXxel5CVcCqf3qu/5ROgy8hPsr6aAWCJKRJUq4X/HIBKmr358gCoSXzGG9M/6svUcyjBUF4BgaCffB621GWRuYraAUDkeI3Epj8qPKD8pl3cUfNl1Q4SSme+rAePuOV7rqnNK/srC0YCt0JE94CThJ3rB/MP7RijDjBSkuA1jeHunLhH6S8MUI0VKaCl8EftMa3UqjvB/tUy/yNRGGLni61dC7AemjvuGNOkIkIprwBOIWINaoxrD2fdKIKRQWJpxQ1i0i5zapl8o2e2ZOS+m1LIuO4ORlmUPuiayEsrfNSqaQsZjgnmj3zdjbjBLOK/x5+vcBxE+BcX9hqpehs9w0e1vZoczxyo0eP0m7WYaThws+vmDLn/GV5JpRchUu5wjiZQ2oWeBcJ1g8kmixKAc/5B+XH2NCzs4+ONxdc58LJSZDk/OW0ye82AgL4v9FzrAxEnhtHhzHwZsCxadJ9icO+7V57rG44X6Wi4oYwHk3YlmfPs4cw6UHcs13IrudcBb03W+UlTI35Xl5BHT6PEqdSs/n/+zGa1Go7qnB3QgipKAqNj90w4Vci/CHF67CBYp5kANuq1hk3yB91Vu+gsAhBIm988t6KMxVXEbbncNaihmfZfg2DtHxPUiyvLI0AoJHagqr1uCXgKd+IpzOrAsaUEzzymJSBtBTBrBH/8quhaFNbqImSX/qRtoj8aen5EyrZ+SgXjEaW13TQjC0ZMK7colQgMrL87n8pkGllfU/G8HhSgZ3bD/iID7YNk1niUok7Jah7c1oGDv1hglcNPw7sLsAfI0l6irQ4zQIlwj+Q9xI4excvQBWJkJaEMkNQr3E9MTKz4cdbHya0cciETg07hANd1ncsq9Ut7BThV+NsuKK2Jll34yvFWe2QbU+JzHPC8Vl8mipuEq8HF9Wg5KGzP/7xBidyqfmpYfXGDOogJQZbaWL0kyjIT9STXsb1+9Hd6AZndx6fuNLndVAcdwMe567WDnLCTr0225A6MHc3k9D1/o95jLFrgIYeAurnPWUHBF6okADdrBoNJdYXZRqZZaQ5mKrapHmBVQEfE219odAgCU+0eRuEiNzOW6iB2SCiBYgzJy/n97/S4802SXbuupO8s4OOUKO1B6KSBLhrnsq1ciIG+mYfkpfW6BNbx5fgg/6viXmQ3GC+jgi68ToRWzZoQXMVyotfzBv+TmqgAqq3loNdXeMJiUEB0TjUCPi/eRNLTtInLks51T/JEV4jhO9wqt5CWzzWhuEQ+UZSx19/8t6dQAbmUqAoXtvixiW4UDAkVspLPyBk4WVWIoW1y97H/+tPCuh/bbxXw6i6PBAgz4WnwwEYtoj4z6uWcLI=]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移数据]]></title>
    <url>%2F2018%2F03%2F06%2F%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[本文已经迁移直云端显示正常可以多端协同编辑博客现在这是mac电脑修改的内容//to do现在这是pc电脑修改的内容//to do 正文可以看到新行~~ test syc新行| Tables | Are | Cool || ————- |:————-:| —–:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 新行[] good to know everything is ok. 结尾真是太好了很好很好，已经可以多端协同编写文章了。]]></content>
      <categories>
        <category>Hexo练习</category>
      </categories>
      <tags>
        <tag>迁移</tag>
        <tag>数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒今天天气真好！]]></title>
    <url>%2F2018%2F03%2F02%2F%E3%80%90%E5%8A%A0%E5%AF%86%E3%80%91%E4%BB%8A%E5%A4%A9%E5%A4%A9%E6%B0%94%E7%9C%9F%E5%A5%BD%EF%BC%81%2F</url>
    <content type="text"><![CDATA[请输入密码 U2FsdGVkX1+iXmtcqFFwAtqdJIhPy7fZtrWyOmHy+MxpYmNiWtLoXSmF1QkM1q/CO079n/RELTynFrKTEA2qwUFk2rNpfi8Q2MofeJ4ayg4OXgpIuM0MvUAc+K9c8vEzJcwBBY9q+sI7DHnymnjevXtLSgxPNr4uKZHAX+MlxseRbNwPBx6l7mhPTOzvKc6JqJVtdZ1FXqhJXuChCqayXZiwTWQXUu+FEiQIqPfhtTgd8f2EUt+u/mQiECywh5uf04wvT5tx+yJKXV57/KSzgFRJ0jgCUZIjhVSHK/eN2YIDzmELnw+VLeE6o0hlyrZJyJQqhqRCgTG4W88b6o1KzAuNSA15HYLdA4LJaAKj+gt9df5GzowJtQszioxdbvnxccMtDQVy5D3zU+4Rhn0E6mAYxoiyiFOlNPsGK64eaJ0FUso6whn6fh/OcMhUvtC8WCLnSGZgJOpFiXvI1tvXlts+dR/UZu4UW8G8pULqFbCsTjL1+eoZlmNc6kflnovIksFmGksAbT0XPkSRVsgmSc657x2grkvY/3XcY2gqxQV+C7Ube1DOSJ1wpXXW0OhSNP1RSDdyM/SZQIZ31C52y+bnpSlslRwdY7DzrgZWdq4/6m6abz3nJuS4fjsx8AvfwWhkEo7DbGQKa3HUxec3HTDllUa3Hom3MBgHDH3KMdUCcWD6mkUByEp7K9HiXjYN]]></content>
      <categories>
        <category>Hexo练习</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文]]></title>
    <url>%2F2018%2F03%2F01%2F%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[中文文字显示测试，看看中文是否可以正常显示。 以下是测试内容开始这是一个开始字段换行换行换行换行换行换行换行换行换行换行 内容本文内容相当精彩换行换行换行换行换行换行换行 最后谢谢您的阅读换行换行换行换行换行换行]]></content>
      <categories>
        <category>Hexo练习</category>
      </categories>
      <tags>
        <tag>中文</tag>
        <tag>测试</tag>
        <tag>显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[来自1900]]></title>
    <url>%2F1900%2F03%2F02%2F%E6%9D%A5%E8%87%AA1999%2F</url>
    <content type="text"><![CDATA[假设这篇文章是1900年的老文章。看看hexo是否会自动归类和正确显示时间信息 这里有历史旧闻故事]]></content>
      <categories>
        <category>Hexo练习</category>
      </categories>
      <tags>
        <tag>故事</tag>
        <tag>历史</tag>
        <tag>旧闻</tag>
      </tags>
  </entry>
</search>
