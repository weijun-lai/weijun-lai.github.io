<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[🔒VPN Server]]></title>
    <url>%2F2018%2F04%2F27%2FVPN-Server%2F</url>
    <content type="text"><![CDATA[请输入密码 U2FsdGVkX1+ThBIXt2B1YgbeKZE41PUHzZoYNgNvQW/iCgBFCTu6Uox8ras8ON6MQVa00FZNDxET7ArmzXvKCx9REcnMftJSAr4IpWEb56M=]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java SE 8 Programmer I 1 Z0-808]]></title>
    <url>%2F2018%2F04%2F01%2FJava-SE-8-Programmer-I-1-Z0-808%2F</url>
    <content type="text"><![CDATA[Review Exam TopicsAssume the following:Missing package and import statements: If sample code do not include package or import statements, and the question does not explicitly refer to these missing statements, then assume that all sample code is in the same package, or import statements exist to support them.No file or directory path names for classes: If a question does not state the file names or directory locations of classes, then assume one of the following, whichever will enable the code to compile and run:All classes are in one fileEach class is contained in a separate file, and all files are in one directoryUnintended line breaks: Sample code might have unintended line breaks. If you see a line of code that looks like it has wrapped, and this creates a situation where the wrapping is significant (for example, a quoted String literal has wrapped), assume that the wrapping is an extension of the same line, and the line does not contain a hard carriage return that would cause a compilation failure.Code fragments: A code fragment is a small section of source code that is presented without its context. Assume that all necessary supporting code exists and that the supporting environment fully supports the correct compilation and execution of the code shown and its omitted environment.Descriptive comments: Take descriptive comments, such as “setter and getters go here,” at face value. Assume that correct code exists, compiles, and runs successfully to create the described effect.TOPICS Java BasicsDefine the scope of variablesDefine the structure of a Java classCreate executable Java applications with a main method; run a Java program from the command line; produce console outputImport other Java packages to make them accessible in your codeCompare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc.Working With Java Data TypesDeclare and initialize variables (including casting of primitive data types)Differentiate between object reference variables and primitive variablesKnow how to read or write to object fieldsExplain an Object’s Lifecycle (creation, “dereference by reassignment” and garbage collection)Develop code that uses wrapper classes such as Boolean, Double, and IntegerUsing Operators and Decision ConstructsUse Java operators; use parentheses to override operator precedenceTest equality between Strings and other objects using == and equals ()Create if and if/else and ternary constructsUse a switch statementCreating and Using ArraysDeclare, instantiate, initialize and use a one-dimensional arrayDeclare, instantiate, initialize and use multi-dimensional arraysUsing Loop ConstructsCreate and use while loopsCreate and use for loops including the enhanced for loopCreate and use do/while loopsCompare loop constructsUse break and continueWorking with Methods and EncapsulationCreate methods with arguments and return values; including overloaded methodsApply the static keyword to methods and fieldsCreate and overload constructors; differentiate between default and user defined constructorsApply access modifiersApply encapsulation principles to a classDetermine the effect upon object references and primitive values when they are passed into methods that change the valuesWorking with InheritanceDescribe inheritance and its benefitsDevelop code that makes use of polymorphism; develop code that overrides methods; differentiate between the type of a reference and the type of an objectDetermine when casting is necessaryUse super and this to access objects and constructorsUse abstract classes and interfacesHandling ExceptionsDifferentiate among checked exceptions, unchecked exceptions, and ErrorsCreate a try-catch block and determine how exceptions alter normal program flowDescribe the advantages of Exception handlingCreate and invoke a method that throws an exceptionRecognize common exception classes (such as NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException)Working with Selected classes from the Java APIManipulate data using the StringBuilder class and its methodsCreate and manipulate StringsCreate and manipulate calendar data using classes from java.time.LocalDateTime, java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter, java.time.PeriodDeclare and use an ArrayList of a given typeWrite a simple Lambda expression that consumes a Lambda Predicate expression]]></content>
      <categories>
        <category>IT考试资料</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>认证考试</tag>
        <tag>复习资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习资料]]></title>
    <url>%2F2018%2F04%2F01%2F%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[复习资料前端ECMAScript 6 入门 阮一峰JavaScript-Garden前端农民工个人博客JavaScript 基础问题 后端认证考试oracle 官方认证Java SE CertificationJava EE CertificationJava SE 6 Programmer Certified Professional (retiring May 31, 2018)]]></content>
      <categories>
        <category>IT考试资料</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>认证考试</tag>
        <tag>复习资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒箴言]]></title>
    <url>%2F2018%2F03%2F14%2F%E7%AE%B4%E8%A8%80%2F</url>
    <content type="text"><![CDATA[请输入密码 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]]></content>
      <categories>
        <category>箴言</category>
      </categories>
      <tags>
        <tag>历史</tag>
        <tag>箴言</tag>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[🔒Base32编码]]></title>
    <url>%2F2018%2F03%2F08%2FBase32%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[请输入密码 U2FsdGVkX18t+Qm6X6OUOOLUg5l9fhz0YushBW/dgPjXdqY8ec8euqt0F2Bv+4VJsxd1dAeQs7hcChVXCd81QY9+fRxllT8avSjg46HlmZw87/YxanlLfNlMyN+WbmB8/ERAKrvIzrV7zJJdysiA3YfXxg0m/3KbLB/EDuOVSG2kVVHVmbVNsNHaVuCPPe0Kav28G+UvBwoIRgXSPg9MxxUmEQgqEEtgkYA2MHg35TT9LBS6Hjqvp5cX6E+xj91tXz83YxqvD1lOVoHN9bbVo2POEUXFEDsUT2miwkZhuU4E1VoajjpRi9qNcGiP96jy9IhENXyMwBo7y/IF8KjlkM5RJEceBxq+0UhbmT/N10vwt8E3XI/Dv25TCfes02i54T8jPtUF1rd+fkfgUfk8OqvM9tAoWx6gMBSZYQDMLFzzkxu4nceVAr7DrFc1XMogcdav3oZF11BsWs/r67sP3jn8Uyo7ODJEu1iyvYLxfD5khPFCopk51mm1sUgOG2qy4fHYnFeVif3yTDQV9JPXI3iGbdxJkH2EyKR1ObT1iMU=$(document).ready(function() { $('#header,#comments,#footer,.post-meta,.post-footer').addClass('opacity0InOut');});]]></content>
      <categories>
        <category>计算机基础科学</category>
      </categories>
      <tags>
        <tag>Base32</tag>
        <tag>加密</tag>
        <tag>解密</tag>
        <tag>计算机基础科学</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base64编码]]></title>
    <url>%2F2018%2F03%2F08%2FBase64%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Base64这是一个基于64位字符表示的数字系统，只用64个字符可转换来代表二进制数值或其他进制字符。在计算机科学中这64个字符，一般选取ASCII码其中64个字符来表示数码。Base64有不同的设计版本，对应不同字符表(编码表)，其中前62个字符对应的是：26个字母大小写，10个数字。第63和64位，这最后2个字符因不同的操作系统设计标准，历史不同版本设计协议，和电子通信环境需求，选用了不同符号表示。详细请参考维基百科/wiki/Base64，以下是标准Base64编码表。 Value Char Value Char Value Char Value Char 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 W 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / Base64加密解密算法原理明文字符串,举个栗子abcd,里每个单字符对应ASCII编码表都有二进制的的8位字节表示，如： 原文字符串 ASCII字符码 a b c d ASCII二进制码 01100001 01100010 01100011 01100100 手算数学步骤： 步骤1==&gt; 分段处理字符串，每段读取3个字节 [ 01100001 01100010 01100011] [01100100] 步骤2==&gt; 将每段每个原来的8位3个字节，分成6位4个字节 [ 011000 010110 001001 100011] [011001 00] 步骤3==&gt; 给不足6位4个字节的数据段填充0，输出字符使用 ‘=’ [011000 010110 001001 100011] [011001 000000 000000 000000 ] (可选)步骤4==&gt; 转换成十进制 [ 24 22 9 35 ][ 25 0 = = ] 步骤5==&gt; 查Base64编码表 [ Y W J j ][ Z A = = ] 计算机数学计算步骤：Base64编码 encode加密 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172输入：abcd处理：Base64编码 encode加密输出：YWJjZA==[a b c] [d][01100001 01100010 01100011] [01100100][011000 01 0110 0010 01 100011] [011001 00]/*---------数据第一分段处理------------*/[01100001 01100010 01100011]// ### 处理第1字节a01100001011000-- &gt;&gt;2 // 01100001向右移2位 01100001=&gt;xx011000011000 24Y //输出结果 Y , 在Base64编码表十进制值为24// ### 处理第2字节a b01100001 01100010------01 &lt;&lt;6 // 高位01100001向左移6位 01100001=&gt;01xxxxxx----0001 &gt;&gt;2 // 01xxxxxx向右移2位 01xxxxxx=&gt;xx01xxxx0110---- &gt;&gt;4 // 低位01100010向右移4位 01100010=&gt;xxxx011001011000010110 //高位 0001xxxx 添加 低位 xxxx0110, 0001xxxx | xxxx0110=0001011022G //输出结果 G , 在Base64编码表十进制值为22// ### 处理第3字节b c01100010 01100011----0010 &lt;&lt;4 // 高位01100010向左移4位 01100010=&gt;0010xxxx--000010 &gt;&gt;2 // 0010xxxx向右移2位 0010xxxx=&gt;xx0010xx01------ &gt;&gt;6 // 低位01100011向右移6位 01100011=&gt;xxxxxx01001001 // 高位 xx0010xx 添加 低位 xxxxxx01, xx0010xx|xxxxxx01=000010019J //输出结果 J , 在Base64编码表十进制值为9// ### 处理第4字节c01100011--100011 // 01100011取最后6位， 即对 00111111 &amp; 01100011 = 0010001135j //输出结果 j , 在Base64编码表十进制值为35/*---------数据第二分段处理------------*/[01100100 00000000 00000000]// ### 处理第1字节d01100100011001-- &gt;&gt;2 // 01100100向右移2位 01100100=&gt;xx0110010110010001100125Z //输出结果 Z , 在Base64编码表十进制值为25// ### 处理第2字节d null01100100 00000000------00 &lt;&lt;6 // 高位01100100向左移6位 01100100=&gt;00xxxxxx----0000 &gt;&gt;2 // 01100100向右移2位 00xxxxxx=&gt;xx00xxxx0000---- &gt;&gt;4 // 低位00000000向右移4位 00000000=&gt;xxxx0000000000 // 高位 xx00xxxx 添加 低位 xxxx0000, xx00xxxx|xxxx0000=00000000000000000A //输出结果 A , 在Base64编码表十进制值为0// ### 处理填充字节null null00000000 00000000= // 输出结果 = , 填充码= // 输出结果 = , 填充码 Base64编码 decode解密 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293输入：YWJjZA==处理：Base64编码 decode解密输出：abcd---------------------------------------Y W J j Z A = =(ascii) --&gt; (base64)[01011001 01010111 01001010][01101010 01011010 00111101 00111101](ascii) Y 01011001 89 - (ascii) A 01000001 65 = (base64) 24 00011000 Y(ascii) W 01010111 87 - (ascii) A 01000001 65 = (base64) 22 00010110 W(ascii) J 01001010 74 - (ascii) A 01000001 65 = (base64) 9 00001001 J(ascii) j 01101010 106 - (ascii) A 01100001 65 - 6 = (base64) 35 00100011 j(ascii) Z 01011010 90 - (ascii) A 01000001 65 = (base64) 25 00011001‬ Z(ascii) = 00111101 61 - (ascii) A 01000001 65 = -4 00000000(ascii) = 00111101 61 - (ascii) A 01000001 65 = -4 00000000[0-9](ascii) 0 00110000 48 - (ascii) A 01000001 65 + 69 = (base64) 52 000011001‬ 0(ascii) 0 00110000 48 - (-4) = (base64) 52 000011001‬ 0(ascii) 9 00110000 57 - (-4) = (base64) 61 000011001‬ 9[a-z](ascii) j 01101010 106 - (ascii) A 01100001 65 - 6 = (base64) 35 00100011 j(ascii) j 01101010 106 - 71 = (base64) 35 00100011 j[+/](ascii) + 00101011 43 - (-19) = (base64) 62 00111110 +(ascii) / 00101111 47 - (-16) = (base64) 63 00111111 /(base64)[00011000 00010110 00001001 00100011] [00011001‬ 00000000 00111101 00111101]00011000 --01 0110 --0010 01 --100011/*---------数据第一分段处理------------*/[00011000 00010110 00001001 00100011] Y W J jY W00011000 0001011000011000 --011000 &lt;&lt;2 //高位00011000 向左移2位 00011000=&gt;011000xx00010110 01---- &gt;&gt;4 //低位00010110 向右移4位 00010110=&gt;xxxx000101100001 //高位011000xx 添加 低位 xxxxxx01, 01100000 | 00000001 = 0110000197a //输出结果 a , 在ASCII编码表十进制值为97W J00010110 0000100100010110----0110 &lt;&lt;4 //高位00010110 向左移4位 00010110=&gt;0110xxxx00001001000010-- &gt;&gt;2 //低位00001001向右移2位 00001001=&gt;xx00001001100010 //高位0110xxxx 添加 低位 xx000010, 0110xxxx | xx000010 = 0110001098b //输出结果 b , 在ASCII编码表十进制值为98J j00001001 0010001100001001------01 &lt;&lt;6 // 高位 00001001向左移6位 00001001=&gt;01xxxxxx00100011 // 保留低位 0010001101100011 // 高位 01xxxxxx 添加 00100011, 01xxxxxx | 00100011 = 0110001199c //输出结果 c , 在ASCII编码表十进制值为99/*---------数据第二分段处理------------*/[00011001‬ 00000000 00111101 00111101] Z A = =Z A00011001‬ 0000000000011001‬ --011001 &lt;&lt;2 // 高位 00011001‬ 向左移2位 00011001‬=&gt;011001‬xx00000000 00---- &gt;&gt;4 // 低位 00000000 向右移4位 00000000=&gt;xxxx000001100100 // 高位 011001‬xx 添加 低位 xxxx0000, 011001‬xx | xxxx0000 = 01100100100d //输出结果 d , 在ASCII编码表十进制值为100A =00000000 0011110100000000----0000 &lt;&lt;4 // 高位 00000000 向左移4位 00000000=&gt;0000xxxx00111101001111-- &gt;&gt;2 // 低位 00111101 向右移2位 00111101=&gt;xx00111100001111 // 高位 0000xxxx 添加 低位 xx001111, 0000xxxx | xx001111 = 000011110x0F15SI (shift in) 启用切换 //输出结果 SI , 在ASCII编码表十进制值为15= =00111101 0011110100111101------01 &lt;&lt;6 // 高位 00001001向左移6位 00111101=&gt;01xxxxxx00111101 // 保留低位 0011110101111101 // 高位 01xxxxxx 添加 00100011, 01xxxxxx | 00111101 = 01111101125&#123; //输出结果 &#123; , 在ASCII编码表十进制值为125 计算机编程语言 JavaScript 代码实现[源代码下载] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227/*** 作者：Weijun Lai** 时间：2018年3月9日** 版本：1.0** 说明：实现Base64编码的加密和解密功能。** 并未对执行效率，最大处理能力和** 书写简洁做优化，仅对算法细分解析。** 为了便于阅读，已将原来一行复合运算代码分解成多行，因此占用了更多变量** 本代码用for循环处理将会有处理字符串长度最大为integer数据类型大小的限制***/// base64编码表var base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";// base64编码表最后两位var char62 = '+';var char63 = '/';base64Table += char62+char63;/*** base64 加密** @param &#123;code&#125; String 输入字符串明文** @return &#123;encode&#125; String 输出字符串密文*/function base64_encode(code) &#123;/* 加密算法流程 1.分段处理，每段处理三字节 以下将每段(8位三字节)转为每段(6位四字节) 2.处理第1字节 2.1高位向右移2位 3.处理第2字节 3.1高位向左移6位 3.2高位向右移2位 3.3高位取最后6位，即 与运算 00111111 (0x3F) 3.4低位向右移4位 3.5高低位或运算 4.处理第3字节 4.1高位向左移4位 4.2高位向右移2位 4.3高位取最后6位，即 与运算 00111111 (0x3F) 4.4低位向右移6位 4.5高低位或运算 5.处理第4字节 5.5取最后6位，即 与运算 00111111 (0x3F) 6.处理分段不足三字节长度的填充 6.1分段内字节数量长度缺2个满足三字节的补2个等号'=' 6.2分段内字节数量长度缺1个满足三字节的补1个等号'='*/ var byte1 = 0; // 寄存处理第1字节的变量 var byte2 = 0; // 寄存处理第2字节的变量 var byte3 = 0; // 寄存处理第3字节的变量 var byte4 = 0; // 寄存处理第4字节的变量 var encode = ""; // 寄存Base64加密后输出结果的变量 // 1.分段处理，每段处理三字节 for (var i=0;i&lt;code.length;i=i+3) &#123; // 2.处理第1字节 byte1 = code[i].charCodeAt(); //获取ascii编码表对应的值 byte1 = byte1&gt;&gt;2; //2.1高位向右移2位 byte1 = byte1&amp;0x3F;//2.3高位取最后6位，即 与运算 00111111 (0x3F) encode += base64Table[byte1]; //查Base64编码表对应的值 // 6.处理分段不足三字节长度的填充 if (i+2-code.length==1) &#123; //6.1分段内字节数量长度缺2个字节满足三字节的补2个等号'=' byte1 = code[i].charCodeAt(); //获取ascii编码表对应的值,记为高位 byte2 = 0; //填充零，记为低位 byte1 = byte1&lt;&lt;6;//3.1高位向左移6位 byte1 = byte1&gt;&gt;2;//3.2高位向右移2位 byte1 = byte1&amp;0x3F;//3.3高位取最后6位，即 与运算 00111111 (0x3F) byte2 = byte2&gt;&gt;4;//3.4低位向右移4位 byte2 = byte1|byte2;//3.5高低位或运算 encode += base64Table[byte2]; //查Base64编码表对应的值 encode += "=="; break; &#125; // 处理第2字节 byte1 = code[i].charCodeAt(); //获取ascii编码表对应的值,记为高位 byte2 = code[i+1].charCodeAt(); //获取ascii编码表对应的值,记为低位 byte1 = byte1&lt;&lt;6;//3.1高位向左移6位 byte1 = byte1&gt;&gt;2;//3.2高位向右移2位 byte1 = byte1&amp;0x3F;//3.3高位取最后6位，即 与运算 00111111 (0x3F) byte2 = byte2&gt;&gt;4;//3.4低位向右移4位 byte2 = byte1|byte2;//3.5高低位或运算 encode += base64Table[byte2]; //查Base64编码表对应的值 // 6.处理分段不足三字节长度的填充 if (i+2-code.length==0) &#123; //6.2分段内字节数量长度缺1个字节满足三字节的补1个等号'=' byte2 = code[i+1].charCodeAt(); //获取ascii编码表对应的值,记为高位 byte3 = 0; //填充零，记为低位 byte2 = byte2&lt;&lt;4;//4.1高位向左移4位 byte2 = byte2&gt;&gt;2;//4.2高位向右移2位 byte2 = byte2&amp;0x3F;//4.3高位取最后6位，即 与运算 00111111 (0x3F) byte3 = byte3&gt;&gt;6;//4.4低位向右移6位 byte3 = byte2|byte3;//4.5高低位或运算 encode += base64Table[byte3]; //查Base64编码表对应的值 encode += "="; break; &#125; // 处理第3字节 byte2 = code[i+1].charCodeAt(); //获取ascii编码表对应的值,记为高位 byte3 = code[i+2].charCodeAt(); //获取ascii编码表对应的值,记为低位 byte2 = byte2&lt;&lt;4;//4.1高位向左移4位 byte2 = byte2&gt;&gt;2;//4.2高位向右移2位 byte2 = byte2&amp;0x3F;//4.3高位取最后6位，即 与运算 00111111 (0x3F) byte3 = byte3&gt;&gt;6;//4.4低位向右移6位 byte3 = byte2|byte3;//4.5高低位或运算 encode += base64Table[byte3]; //查Base64编码表对应的值 // 处理第4字节 byte4 = code[i+2].charCodeAt(); //获取ascii编码表对应的值 byte4 = byte4&amp;0x3F;//5.5取最后6位，即 与运算 00111111 (0x3F) encode += base64Table[byte4]; //查Base64编码表对应的值 &#125; return encode;&#125;/* ascii编码表 映射ascii编码 到 base64编码表** @param &#123;char&#125; 输入单字符** @return &#123;integer&#125; 输出整数*/function asciiToBase64(code) &#123; var char = ""; try&#123; char = code.charCodeAt(); &#125;catch (e)&#123; return -1; &#125; if (char == char62.charCodeAt()) &#123; // '+' 的ascii编码映射base64编码 return 62; &#125; else if (char == char63.charCodeAt()) &#123; // '-' 的ascii编码映射base64编码 return 63; &#125; else if (char &gt;= '0'.charCodeAt() &amp;&amp; char &lt;= '9'.charCodeAt()) &#123; // [0-9]范围的ascii编码映射到[0-9]范围的base64编码 return char+4; &#125; else if (char &gt;= 'A'.charCodeAt() &amp;&amp; char &lt;= 'Z'.charCodeAt()) &#123; // [A-Z]范围的ascii编码映射到[A-Z]范围的base64编码 return char-65; &#125; else if (char &gt;= 'a'.charCodeAt() &amp;&amp; char &lt;= 'z'.charCodeAt()) &#123; // [a-z]范围的ascii编码映射到[a-z]范围的base64编码 return char-71; &#125; return -1;&#125;/*** base64 解密** @param &#123;code&#125; String 输入字符串密文** @return &#123;encode&#125; String 输出字符串明文*/function base64_decode(code) &#123; /* 解密算法流程 1.分段处理，每段四字节，将每个加密字节从ascii编码表映射到Base64编码表 以下将每段(8位四字节)转为每段(8位三字节) 2.处理第1字节 2.1高位向左移2位 2.2高位取最后8位，即 与运算 11111111 (0xFF) 2.3低位向右移4位 2.4高低位或运算 3.处理第2字节 3.1高位向左移4位 3.2高位取最后8位，即 与运算 11111111 (0xFF) 3.3低位向右移2位 3.4高低位或运算 4.处理第3字节 4.1高位向左移6位 4.2高位取最后8位，即 与运算 11111111 (0xFF) 4.3低位保留 4.4高低位或运算 5.处理填充代表等号字符= 5.1结束处理 */ var byte1 = 0; // 寄存处理第1字节的变量 var byte2 = 0; // 寄存处理第2字节的变量 var byte3 = 0; // 寄存处理第3字节的变量 var byte4 = 0; // 寄存处理第4字节的变量 var decode = ""; // 寄存Base64解密后输出结果的变量 //1.分段处理，每段四字节，将每个加密字节从ascii编码表映射到Base64编码表 for (var i=0;i&lt;code.length;i=i+4) &#123; //5.处理填充代表等号字符= if (asciiToBase64(code[i])==-1 || asciiToBase64(code[i+1])==-1) &#123; break; &#125; //2.处理第1字节 byte1 = asciiToBase64(code[i]);//获取ascii编码表映射到Base64编码表对应的值,记为高位 byte2 = asciiToBase64(code[i+1]);//获取ascii编码表映射到Base64编码表对应的值,记为低位 byte1 = byte1&lt;&lt;2;//2.1高位向左移2位 byte1 = byte1&amp;0xFF;//2.2高位取最后8位，即 与运算 11111111 (0xFF) byte2 = byte2&gt;&gt;4;//2.3低位向右移4位 byte1 = byte1|byte2;//2.4高低位或运算 decode += String.fromCharCode(byte1);//查ascii编码表对应的值 //5.处理填充代表等号字符= if (asciiToBase64(code[i+1])==-1 || asciiToBase64(code[i+2])==-1) &#123; break; &#125; //3.处理第2字节 byte2 = asciiToBase64(code[i+1]);//获取ascii编码表映射到Base64编码表对应的值,记为高位 byte3 = asciiToBase64(code[i+2]);//获取ascii编码表映射到Base64编码表对应的值,记为低位 byte2 = byte2&lt;&lt;4;//3.1高位向左移4位 byte2 = byte2&amp;0xFF;//2.3高位取最后8位，即 与运算 11111111 (0xFF) byte3 = byte3&gt;&gt;2;//2.3低位向右移2位 byte2 = byte2|byte3;//2.4高低位或运算 decode += String.fromCharCode(byte2);//查ascii编码表对应的值 //5.处理填充代表等号字符= if (asciiToBase64(code[i+2])==-1 || asciiToBase64(code[i+3])==-1) &#123; break; &#125; //4.处理第3字节 byte3 = asciiToBase64(code[i+2]);//获取ascii编码表映射到Base64编码表对应的值,记为高位 byte4 = asciiToBase64(code[i+3]);//获取ascii编码表映射到Base64编码表对应的值,记为低位 byte3 = byte3&lt;&lt;6;//3.1高位向左移6位 byte3 = byte3&amp;0xFF;//2.3高位取最后8位，即 与运算 11111111 (0xFF) byte4 = byte4;//2.3低位保留 byte3 = byte3|byte4;//2.4高低位或运算 decode += String.fromCharCode(byte3);//查ascii编码表对应的值 &#125; return decode;&#125; 来自 crypto-js.js Base64部分源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104(function () &#123; // Shortcuts var C = CryptoJS; var C_lib = C.lib; var WordArray = C_lib.WordArray; var C_enc = C.enc; /** * Base64 encoding strategy. */ var Base64 = C_enc.Base64 = &#123; /** * Converts a word array to a Base64 string. * * @param &#123;WordArray&#125; wordArray The word array. * * @return &#123;string&#125; The Base64 string. * * @static * * @example * * var base64String = CryptoJS.enc.Base64.stringify(wordArray); */ stringify: function (wordArray) &#123; // Shortcuts var words = wordArray.words; var sigBytes = wordArray.sigBytes; var map = this._map; // Clamp excess bits wordArray.clamp(); // Convert var base64Chars = []; for (var i = 0; i &lt; sigBytes; i += 3) &#123; var byte1 = (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff; var byte2 = (words[(i + 1) &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - ((i + 1) % 4) * 8)) &amp; 0xff; var byte3 = (words[(i + 2) &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - ((i + 2) % 4) * 8)) &amp; 0xff; var triplet = (byte1 &lt;&lt; 16) | (byte2 &lt;&lt; 8) | byte3; for (var j = 0; (j &lt; 4) &amp;&amp; (i + j * 0.75 &lt; sigBytes); j++) &#123; base64Chars.push(map.charAt((triplet &gt;&gt;&gt; (6 * (3 - j))) &amp; 0x3f)); &#125; &#125; // Add padding var paddingChar = map.charAt(64); if (paddingChar) &#123; while (base64Chars.length % 4) &#123; base64Chars.push(paddingChar); &#125; &#125; return base64Chars.join(''); &#125;, /** * Converts a Base64 string to a word array. * * @param &#123;string&#125; base64Str The Base64 string. * * @return &#123;WordArray&#125; The word array. * * @static * * @example * * var wordArray = CryptoJS.enc.Base64.parse(base64String); */ parse: function (base64Str) &#123; // Shortcuts var base64StrLength = base64Str.length; var map = this._map; // Ignore padding var paddingChar = map.charAt(64); if (paddingChar) &#123; var paddingIndex = base64Str.indexOf(paddingChar); if (paddingIndex != -1) &#123; base64StrLength = paddingIndex; &#125; &#125; // Convert var words = []; var nBytes = 0; for (var i = 0; i &lt; base64StrLength; i++) &#123; if (i % 4) &#123; var bits1 = map.indexOf(base64Str.charAt(i - 1)) &lt;&lt; ((i % 4) * 2); var bits2 = map.indexOf(base64Str.charAt(i)) &gt;&gt;&gt; (6 - (i % 4) * 2); var bitsCombined = bits1 | bits2; words[nBytes &gt;&gt;&gt; 2] |= (bitsCombined) &lt;&lt; (24 - (nBytes % 4) * 8); nBytes++; &#125; &#125; return WordArray.create(words, nBytes); &#125;, _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=' &#125;;&#125;());]]></content>
      <categories>
        <category>计算机基础科学</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>解密</tag>
        <tag>计算机基础科学</tag>
        <tag>原理</tag>
        <tag>Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下载地址解析]]></title>
    <url>%2F2018%2F03%2F07%2F%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 应用程序 By Weijun Lai, Version: 1.0 请输入下载链接地址：迅雷 快车 旋风 磁力 解析转换 0x02 技术解析： 各类下载链接地址都有固定的编码格式，便于网络通信程序识别和处理。以下收集了些各类常见链接协议的固定格式。 0x021 固定格式 &#124; HTTP链接地址 http:// 12&lt;明文URL&gt;http://laiweijun.com/file.txt 迅雷链接地址 thunder:// 123456thunder://AA&lt;明文URL&gt;ZZ[处理]AA&lt;明文URL&gt;ZZ ==&gt; AAhttp://laiweijun.com/file.txtZZ==&gt; Base64编码 ==&gt; QUFodHRwJTNBLy9sYWl3ZWlqdW4uY29tL2ZpbGUudHh0Wlo=[输出]thunder://QUFodHRwJTNBLy9sYWl3ZWlqdW4uY29tL2ZpbGUudHh0Wlo= 磁力链接格式 magnet:? 1234magnet:?xl=&lt;字节大小&gt; &amp; dn=&lt;文件名(已编码URL)&gt; &amp; xt=urn:tree:tiger:&lt;TTH hash(Base32)&gt;magnet:?xt=urn:btih:D84ABC1F6605F03BC363E758805EC1A1550DA751v1: magnet:?xt=urn:btih:&lt;info-hash&gt;&amp;dn=&lt;name&gt;&amp;tr=&lt;tracker-url&gt;&amp;x.pe=&lt;peer-address&gt;v2: magnet:?xt=urn:btmh:&lt;tagged-info-hash&gt;&amp;dn=&lt;name&gt;&amp;tr=&lt;tracker-url&gt;&amp;x.pe=&lt;peer-address&gt; 参数 dn（显示名称）- display name的缩写，表示向用户显示的文件名。这是可选项。 xl（绝对长度）- 文件字节数 xt（eXact Topic）- exact topic的缩写，包含文件散列函数值的 URN, 表示资源定位点 BTIH（BitTorrent Info Hash）表示哈希方法名，这里还可以使用SHA1和MD5 as（可接受来源） - 在线文件的网络链接 xs（绝对资源）- P2P链接 kt（关键字）- 用于搜索的关键字 mt（文件列表）- 链接到一个包含磁力连结的元文件 (MAGMA - MAGnet MAnifest) tr（Tracker 地址）- BT下载的Tracker URL 快车链接地址 flashget:// 1234flashget://[FLASHGET]&lt;明文URL&gt;[FLASHGET]==&gt; [FLASHGET]http://laiweijun.com/file.txt[FLASHGET]==&gt; Base64编码 ==&gt; JTVCRkxBU0hHRVQlNURodHRwJTNBLy9sYWl3ZWlqdW4uY29tL2ZpbGUudHh0JTVCRkxBU0hHRVQlNUQ=&amp;anycodeflashget://JTVCRkxBU0hHRVQlNURodHRwJTNBLy9sYWl3ZWlqdW4uY29tL2ZpbGUudHh0JTVCRkxBU0hHRVQlNUQ=&amp;anycode 旋风链接地址 qqdl:// 12qqdl://&lt;已编码URL&gt;qqdl://aHR0cCUzQS8vbGFpd2VpanVuLmNvbS9maWxlLnR4dA== 电驴链接地址 ed2k:// 12ed2k://|file|&lt;文件名称&gt;|&lt;文件大小&gt;|&lt;文件哈希值&gt;|/ed2k://|file|cn_windows_10_multi-edition_vl_version_1709_updated_dec_2017_x64_dvd_100406208.iso|5007116288|317BDC520FA2DD6005CBA8293EA06DF6|/ 0x022 编码Base64 Base32 Base16 Base85 Base16 Base64详细可查看Base64编码这篇文章 Base32详细可查看Base32编码这篇文章]]></content>
      <categories>
        <category>WebApp</category>
      </categories>
      <tags>
        <tag>下载</tag>
        <tag>解析</tag>
        <tag>应用</tag>
        <tag>迅雷</tag>
        <tag>磁力</tag>
        <tag>快车</tag>
        <tag>旋风</tag>
        <tag>电驴</tag>
        <tag>BT种子</tag>
      </tags>
  </entry>
</search>
